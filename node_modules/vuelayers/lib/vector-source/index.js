/**
 * VueLayers
 * Web map Vue components with the power of OpenLayers
 *
 * @package vuelayers
 * @author Vladimir Vershinin <ghettovoice@gmail.com>
 * @version 0.11.23
 * @license MIT
 * @copyright (c) 2017-2020, Vladimir Vershinin <ghettovoice@gmail.com>
 */
import _Object$defineProperty from '@babel/runtime-corejs3/core-js-stable/object/define-property';
import _Object$defineProperties from '@babel/runtime-corejs3/core-js-stable/object/define-properties';
import _Object$getOwnPropertyDescriptors from '@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptors';
import _Object$getOwnPropertyDescriptor from '@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptor';
import _filterInstanceProperty from '@babel/runtime-corejs3/core-js-stable/instance/filter';
import _Object$getOwnPropertySymbols from '@babel/runtime-corejs3/core-js-stable/object/get-own-property-symbols';
import _Object$keys from '@babel/runtime-corejs3/core-js-stable/object/keys';
import _slicedToArray from '@babel/runtime-corejs3/helpers/esm/slicedToArray';
import _sliceInstanceProperty from '@babel/runtime-corejs3/core-js-stable/instance/slice';
import _forEachInstanceProperty from '@babel/runtime-corejs3/core-js-stable/instance/for-each';
import _defineProperty from '@babel/runtime-corejs3/helpers/esm/defineProperty';
import _bindInstanceProperty from '@babel/runtime-corejs3/core-js-stable/instance/bind';
import _regeneratorRuntime from '@babel/runtime-corejs3/regenerator';
import _Array$isArray from '@babel/runtime-corejs3/core-js-stable/array/is-array';
import _asyncToGenerator from '@babel/runtime-corejs3/helpers/esm/asyncToGenerator';
import VectorSource from 'ol/source/Vector';
import { vectorSource } from '../mixin';
import { createGeoJsonFmt, getFeatureId, initializeFeature, loadingAll, transform } from '../ol-ext';
import { constant, difference, isEqual, isFinite, isFunction, stubArray, pick } from '../util/minilo';
import { makeWatchers } from '../util/vue-helpers';
import '@babel/runtime-corejs3/core-js-stable/instance/concat';
import _Object$assign from '@babel/runtime-corejs3/core-js-stable/object/assign';

function ownKeys(object, enumerableOnly) { var keys = _Object$keys(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); if (enumerableOnly) symbols = _filterInstanceProperty(symbols).call(symbols, function (sym) { return _Object$getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { var _context5; _forEachInstanceProperty(_context5 = ownKeys(Object(source), true)).call(_context5, function (key) { _defineProperty(target, key, source[key]); }); } else if (_Object$getOwnPropertyDescriptors) { _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)); } else { var _context6; _forEachInstanceProperty(_context6 = ownKeys(Object(source))).call(_context6, function (key) { _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key)); }); } } return target; }
var script = {
  name: 'vl-source-vector',
  mixins: [vectorSource],
  props: {
    /**
     * Array of GeoJSON features with coordinates in the map view projection.
     * @type {Object[]} features
     */
    features: {
      type: Array,
      default: stubArray
    },

    /**
     * Source loader factory.
     * Source loader should load features from some remote service, decode them and pas to `features` prop to render.
     * @type {(function(): FeatureLoader|undefined)} loaderFactory
     */
    loaderFactory: {
      type: Function
    },

    /**
     * Source format factory
     * @type {(function(): Feature|undefined)} formatFactory
     */
    formatFactory: {
      type: Function,
      default: defaultFormatFactory
    },

    /**
     * String or url factory
     * @type {(string|function(): string|FeatureUrlFunction|undefined)} url
     */
    url: [String, Function],

    /**
     * Loading strategy factory.
     * Extent here in map view projection.
     * @type {(function(): LoadingStrategy|undefined)} strategyFactory
     */
    strategyFactory: {
      type: Function,
      default: defaultStrategyFactory
    },
    overlaps: {
      type: Boolean,
      default: true
    }
  },
  computed: {
    urlFunc: function urlFunc() {
      var _this = this;

      if (!this.url) return;
      var url = this.url;

      if (!isFunction(url)) {
        url = constant(this.url);
      }

      return function (extent, resolution, projection) {
        extent = transformExtent(extent, projection, _this.resolvedDataProjection);
        projection = _this.resolvedDataProjection;
        return url(extent, resolution, projection);
      };
    },
    loaderFunc: function loaderFunc() {
      var _this2 = this;

      if (!this.loaderFactory) return;
      var loader = this.loaderFactory();
      return /*#__PURE__*/function () {
        var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(extent, resolution, projection) {
          var features;
          return _regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  _context.next = 2;
                  return loader(transformExtent(extent, projection, _this2.resolvedDataProjection), resolution, _this2.resolvedDataProjection);

                case 2:
                  features = _context.sent;

                  if (!_Array$isArray(features)) {
                    features = _this2.readSourceData(features);
                  }

                  if (_Array$isArray(features)) {
                    _this2.addFeatures(features);
                  }

                case 5:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }));

        return function (_x, _x2, _x3) {
          return _ref.apply(this, arguments);
        };
      }();
    },
    loadingStrategy: function loadingStrategy() {
      return this.strategyFactory();
    },
    dataFormatIdent: function dataFormatIdent() {
      if (!this.olObjIdent) return;
      return this.makeIdent(this.olObjIdent, 'data_format');
    },
    dataFormat: function dataFormat() {
      var _context2;

      return this.instanceFactoryCall(this.dataFormatIdent, _bindInstanceProperty(_context2 = this.formatFactory).call(_context2, this));
    }
  },
  methods: {
    /**
     * @return {VectorSource}
     * @protected
     */
    createSource: function createSource() {
      return new VectorSource({
        attributions: this.attributions,
        features: this.$featuresCollection,
        projection: this.resolvedDataProjection,
        loader: this.loaderFunc,
        useSpatialIndex: this.useSpatialIndex,
        wrapX: this.wrapX,
        logo: this.logo,
        strategy: this.loadingStrategy,
        format: this.dataFormat,
        url: this.urlFunc,
        overlaps: this.overlaps
      });
    },

    /**
     * @return {void}
     * @protected
     */
    mount: function mount() {
      vectorSource.methods.mount.call(this);
      this.addFeatures(this.features);
    },

    /**
     * @return {void}
     * @protected
     */
    unmount: function unmount() {
      this.clear();
      vectorSource.methods.unmount.call(this);
    },

    /**
     * @param {mixed} data
     * @returns {Array<FeatureLike>|Array<Feature>}
     */
    readSourceData: function readSourceData(data) {
      return this.dataFormat.readFeatures(data, {
        featureProjection: this.viewProjection,
        dataProjection: this.resolvedDataProjection
      });
    }
  },
  watch: _objectSpread({
    features: {
      deep: true,
      handler: function handler(features) {
        var _this3 = this,
            _context3,
            _context4;

        if (!this.$source || isEqual(features, this.featuresDataProj)) return; // add new features

        _forEachInstanceProperty(features).call(features, function (feature) {
          feature = initializeFeature(_objectSpread({}, feature));

          _this3.addFeature(feature);
        }); // remove non-matched features


        _forEachInstanceProperty(_context3 = difference(this.getFeatures(), features, function (a, b) {
          return getFeatureId(a) === getFeatureId(b);
        })).call(_context3, _bindInstanceProperty(_context4 = this.removeFeature).call(_context4, this));
      }
    }
  }, makeWatchers(['loadingStrategy', 'dataFormat', 'urlFunc', 'loaderFactory', 'formatFactory', 'strategyFactory', 'overlaps'], function () {
    return function () {
      this.scheduleRecreate();
    };
  }))
};
/**
 * @return {LoadingStrategy}
 */

function defaultStrategyFactory() {
  return loadingAll;
}
/**
 * @return {GeoJSON}
 */


function defaultFormatFactory() {
  return createGeoJsonFmt();
}

function transformExtent(extent, sourceProj, destProj) {
  extent = _sliceInstanceProperty(extent).call(extent);

  if (isFinite(extent[0]) && isFinite(extent[1])) {
    var _transform = transform([extent[0], extent[1]], sourceProj, destProj);

    var _transform2 = _slicedToArray(_transform, 2);

    extent[0] = _transform2[0];
    extent[1] = _transform2[1];
  }

  if (isFinite(extent[2]) && isFinite(extent[3])) {
    var _transform3 = transform([extent[2], extent[3]], sourceProj, destProj);

    var _transform4 = _slicedToArray(_transform3, 2);

    extent[2] = _transform4[0];
    extent[3] = _transform4[1];
  }

  return extent;
}

var __vue_script__ = script;
/* template */

/* style */

var __vue_inject_styles__ = undefined;
/* scoped */

var __vue_scope_id__ = undefined;
/* module identifier */

var __vue_module_identifier__ = undefined;
/* functional template */

var __vue_is_functional_template__ = undefined;
/* component normalizer */

function __vue_normalize__(template, style, script$$1, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
  var component = (typeof script$$1 === 'function' ? script$$1.options : script$$1) || {}; // For security concerns, we use only base name in production mode.

  component.__file = "source.vue";

  if (!component.render) {
    component.render = template.render;
    component.staticRenderFns = template.staticRenderFns;
    component._compiled = true;
    if (functional) component.functional = true;
  }

  component._scopeId = scope;

  return component;
}
/* style inject */

/* style inject SSR */


var Source = __vue_normalize__({}, __vue_inject_styles__, __vue_script__, __vue_scope_id__, __vue_is_functional_template__, __vue_module_identifier__, undefined, undefined);

function plugin(Vue) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (plugin.installed) {
    return;
  }

  plugin.installed = true;
  options = pick(options, 'dataProjection');

  _Object$assign(Source, options);

  Vue.component(Source.name, Source);
}

export default plugin;
export { Source, plugin as install };
