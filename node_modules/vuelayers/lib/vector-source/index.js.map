{"version":3,"file":"index.js","sources":["src/component/vector-source/source.vue?rollup-plugin-vue=script.js","src/component/vector-source/source.vue","src/component/vector-source/index.js"],"sourcesContent":["\nimport VectorSource from 'ol/source/Vector'\nimport { vectorSource } from '../../mixin'\nimport { createGeoJsonFmt, getFeatureId, initializeFeature, loadingAll, transform } from '../../ol-ext'\nimport { constant, difference, isEqual, isFinite, isFunction, stubArray } from '../../util/minilo'\nimport { makeWatchers } from '../../util/vue-helpers'\n\nexport default {\n  name: 'vl-source-vector',\n  mixins: [vectorSource],\n  props: {\n    /**\n     * Array of GeoJSON features with coordinates in the map view projection.\n     * @type {Object[]} features\n     */\n    features: {\n      type: Array,\n      default: stubArray,\n    },\n    /**\n     * Source loader factory.\n     * Source loader should load features from some remote service, decode them and pas to `features` prop to render.\n     * @type {(function(): FeatureLoader|undefined)} loaderFactory\n     */\n    loaderFactory: {\n      type: Function,\n    },\n    /**\n     * Source format factory\n     * @type {(function(): Feature|undefined)} formatFactory\n     */\n    formatFactory: {\n      type: Function,\n      default: defaultFormatFactory,\n    },\n    /**\n     * String or url factory\n     * @type {(string|function(): string|FeatureUrlFunction|undefined)} url\n     */\n    url: [String, Function],\n    /**\n     * Loading strategy factory.\n     * Extent here in map view projection.\n     * @type {(function(): LoadingStrategy|undefined)} strategyFactory\n     */\n    strategyFactory: {\n      type: Function,\n      default: defaultStrategyFactory,\n    },\n    overlaps: {\n      type: Boolean,\n      default: true,\n    },\n  },\n  computed: {\n    urlFunc () {\n      if (!this.url) return\n\n      let url = this.url\n      if (!isFunction(url)) {\n        url = constant(this.url)\n      }\n\n      return (extent, resolution, projection) => {\n        extent = transformExtent(extent, projection, this.resolvedDataProjection)\n        projection = this.resolvedDataProjection\n\n        return url(extent, resolution, projection)\n      }\n    },\n    loaderFunc () {\n      if (!this.loaderFactory) return\n\n      const loader = this.loaderFactory()\n\n      return async (extent, resolution, projection) => {\n        let features = await loader(\n          transformExtent(extent, projection, this.resolvedDataProjection),\n          resolution,\n          this.resolvedDataProjection,\n        )\n        if (!Array.isArray(features)) {\n          features = this.readSourceData(features)\n        }\n        if (Array.isArray(features)) {\n          this.addFeatures(features)\n        }\n      }\n    },\n    loadingStrategy () {\n      return this.strategyFactory()\n    },\n    dataFormatIdent () {\n      if (!this.olObjIdent) return\n\n      return this.makeIdent(this.olObjIdent, 'data_format')\n    },\n    dataFormat () {\n      return this.instanceFactoryCall(this.dataFormatIdent, ::this.formatFactory)\n    },\n  },\n  methods: {\n    /**\n     * @return {VectorSource}\n     * @protected\n     */\n    createSource () {\n      return new VectorSource({\n        attributions: this.attributions,\n        features: this.$featuresCollection,\n        projection: this.resolvedDataProjection,\n        loader: this.loaderFunc,\n        useSpatialIndex: this.useSpatialIndex,\n        wrapX: this.wrapX,\n        logo: this.logo,\n        strategy: this.loadingStrategy,\n        format: this.dataFormat,\n        url: this.urlFunc,\n        overlaps: this.overlaps,\n      })\n    },\n    /**\n     * @return {void}\n     * @protected\n     */\n    mount () {\n      this::vectorSource.methods.mount()\n      this.addFeatures(this.features)\n    },\n    /**\n     * @return {void}\n     * @protected\n     */\n    unmount () {\n      this.clear()\n      this::vectorSource.methods.unmount()\n    },\n    /**\n     * @param {mixed} data\n     * @returns {Array<FeatureLike>|Array<Feature>}\n     */\n    readSourceData (data) {\n      return this.dataFormat.readFeatures(data, {\n        featureProjection: this.viewProjection,\n        dataProjection: this.resolvedDataProjection,\n      })\n    },\n  },\n  watch: {\n    features: {\n      deep: true,\n      handler (features) {\n        if (!this.$source || isEqual(features, this.featuresDataProj)) return\n        // add new features\n        features.forEach(feature => {\n          feature = initializeFeature({ ...feature })\n          this.addFeature(feature)\n        })\n        // remove non-matched features\n        difference(\n          this.getFeatures(),\n          features,\n          (a, b) => getFeatureId(a) === getFeatureId(b)\n        ).forEach(::this.removeFeature)\n      },\n    },\n    ...makeWatchers([\n      'loadingStrategy',\n      'dataFormat',\n      'urlFunc',\n      'loaderFactory',\n      'formatFactory',\n      'strategyFactory',\n      'overlaps',\n    ], () => function () {\n      this.scheduleRecreate()\n    }),\n  },\n}\n\n/**\n * @return {LoadingStrategy}\n */\nfunction defaultStrategyFactory () {\n  return loadingAll\n}\n\n/**\n * @return {GeoJSON}\n */\nfunction defaultFormatFactory () {\n  return createGeoJsonFmt()\n}\n\nfunction transformExtent (extent, sourceProj, destProj) {\n  extent = extent.slice()\n  if (isFinite(extent[0]) && isFinite(extent[1])) {\n    [extent[0], extent[1]] = transform([extent[0], extent[1]], sourceProj, destProj)\n  }\n  if (isFinite(extent[2]) && isFinite(extent[3])) {\n    [extent[2], extent[3]] = transform([extent[2], extent[3]], sourceProj, destProj)\n  }\n  return extent\n}\n","<script>\n  import VectorSource from 'ol/source/Vector'\n  import { vectorSource } from '../../mixin'\n  import { createGeoJsonFmt, getFeatureId, initializeFeature, loadingAll, transform } from '../../ol-ext'\n  import { constant, difference, isEqual, isFinite, isFunction, stubArray } from '../../util/minilo'\n  import { makeWatchers } from '../../util/vue-helpers'\n\n  export default {\n    name: 'vl-source-vector',\n    mixins: [vectorSource],\n    props: {\n      /**\n       * Array of GeoJSON features with coordinates in the map view projection.\n       * @type {Object[]} features\n       */\n      features: {\n        type: Array,\n        default: stubArray,\n      },\n      /**\n       * Source loader factory.\n       * Source loader should load features from some remote service, decode them and pas to `features` prop to render.\n       * @type {(function(): FeatureLoader|undefined)} loaderFactory\n       */\n      loaderFactory: {\n        type: Function,\n      },\n      /**\n       * Source format factory\n       * @type {(function(): Feature|undefined)} formatFactory\n       */\n      formatFactory: {\n        type: Function,\n        default: defaultFormatFactory,\n      },\n      /**\n       * String or url factory\n       * @type {(string|function(): string|FeatureUrlFunction|undefined)} url\n       */\n      url: [String, Function],\n      /**\n       * Loading strategy factory.\n       * Extent here in map view projection.\n       * @type {(function(): LoadingStrategy|undefined)} strategyFactory\n       */\n      strategyFactory: {\n        type: Function,\n        default: defaultStrategyFactory,\n      },\n      overlaps: {\n        type: Boolean,\n        default: true,\n      },\n    },\n    computed: {\n      urlFunc () {\n        if (!this.url) return\n\n        let url = this.url\n        if (!isFunction(url)) {\n          url = constant(this.url)\n        }\n\n        return (extent, resolution, projection) => {\n          extent = transformExtent(extent, projection, this.resolvedDataProjection)\n          projection = this.resolvedDataProjection\n\n          return url(extent, resolution, projection)\n        }\n      },\n      loaderFunc () {\n        if (!this.loaderFactory) return\n\n        const loader = this.loaderFactory()\n\n        return async (extent, resolution, projection) => {\n          let features = await loader(\n            transformExtent(extent, projection, this.resolvedDataProjection),\n            resolution,\n            this.resolvedDataProjection,\n          )\n          if (!Array.isArray(features)) {\n            features = this.readSourceData(features)\n          }\n          if (Array.isArray(features)) {\n            this.addFeatures(features)\n          }\n        }\n      },\n      loadingStrategy () {\n        return this.strategyFactory()\n      },\n      dataFormatIdent () {\n        if (!this.olObjIdent) return\n\n        return this.makeIdent(this.olObjIdent, 'data_format')\n      },\n      dataFormat () {\n        return this.instanceFactoryCall(this.dataFormatIdent, ::this.formatFactory)\n      },\n    },\n    methods: {\n      /**\n       * @return {VectorSource}\n       * @protected\n       */\n      createSource () {\n        return new VectorSource({\n          attributions: this.attributions,\n          features: this.$featuresCollection,\n          projection: this.resolvedDataProjection,\n          loader: this.loaderFunc,\n          useSpatialIndex: this.useSpatialIndex,\n          wrapX: this.wrapX,\n          logo: this.logo,\n          strategy: this.loadingStrategy,\n          format: this.dataFormat,\n          url: this.urlFunc,\n          overlaps: this.overlaps,\n        })\n      },\n      /**\n       * @return {void}\n       * @protected\n       */\n      mount () {\n        this::vectorSource.methods.mount()\n        this.addFeatures(this.features)\n      },\n      /**\n       * @return {void}\n       * @protected\n       */\n      unmount () {\n        this.clear()\n        this::vectorSource.methods.unmount()\n      },\n      /**\n       * @param {mixed} data\n       * @returns {Array<FeatureLike>|Array<Feature>}\n       */\n      readSourceData (data) {\n        return this.dataFormat.readFeatures(data, {\n          featureProjection: this.viewProjection,\n          dataProjection: this.resolvedDataProjection,\n        })\n      },\n    },\n    watch: {\n      features: {\n        deep: true,\n        handler (features) {\n          if (!this.$source || isEqual(features, this.featuresDataProj)) return\n          // add new features\n          features.forEach(feature => {\n            feature = initializeFeature({ ...feature })\n            this.addFeature(feature)\n          })\n          // remove non-matched features\n          difference(\n            this.getFeatures(),\n            features,\n            (a, b) => getFeatureId(a) === getFeatureId(b)\n          ).forEach(::this.removeFeature)\n        },\n      },\n      ...makeWatchers([\n        'loadingStrategy',\n        'dataFormat',\n        'urlFunc',\n        'loaderFactory',\n        'formatFactory',\n        'strategyFactory',\n        'overlaps',\n      ], () => function () {\n        this.scheduleRecreate()\n      }),\n    },\n  }\n\n  /**\n   * @return {LoadingStrategy}\n   */\n  function defaultStrategyFactory () {\n    return loadingAll\n  }\n\n  /**\n   * @return {GeoJSON}\n   */\n  function defaultFormatFactory () {\n    return createGeoJsonFmt()\n  }\n\n  function transformExtent (extent, sourceProj, destProj) {\n    extent = extent.slice()\n    if (isFinite(extent[0]) && isFinite(extent[1])) {\n      [extent[0], extent[1]] = transform([extent[0], extent[1]], sourceProj, destProj)\n    }\n    if (isFinite(extent[2]) && isFinite(extent[3])) {\n      [extent[2], extent[3]] = transform([extent[2], extent[3]], sourceProj, destProj)\n    }\n    return extent\n  }\n</script>\n","import { pick } from '../../util/minilo'\nimport Source from './source.vue'\n\nfunction plugin (Vue, options = {}) {\n  if (plugin.installed) {\n    return\n  }\n  plugin.installed = true\n\n  options = pick(options, 'dataProjection')\n  Object.assign(Source, options)\n\n  Vue.component(Source.name, Source)\n}\n\nexport default plugin\n\nexport {\n  Source,\n  plugin as install,\n}\n"],"names":["name","mixins","vectorSource","props","features","type","Array","default","stubArray","loaderFactory","Function","formatFactory","defaultFormatFactory","url","String","strategyFactory","defaultStrategyFactory","overlaps","Boolean","computed","urlFunc","isFunction","constant","extent","resolution","projection","transformExtent","resolvedDataProjection","loaderFunc","loader","readSourceData","addFeatures","loadingStrategy","dataFormatIdent","olObjIdent","makeIdent","dataFormat","instanceFactoryCall","methods","createSource","VectorSource","attributions","$featuresCollection","useSpatialIndex","wrapX","logo","strategy","format","mount","unmount","clear","data","readFeatures","featureProjection","viewProjection","dataProjection","watch","deep","handler","$source","isEqual","featuresDataProj","feature","initializeFeature","addFeature","difference","getFeatures","a","b","getFeatureId","removeFeature","makeWatchers","scheduleRecreate","loadingAll","createGeoJsonFmt","sourceProj","destProj","isFinite","transform","plugin","Vue","options","installed","pick","Source","component"],"mappings":"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"}