{"version":3,"file":"index.js","sources":["src/component/select-interaction/interaction.vue?rollup-plugin-vue=script.js","src/component/select-interaction/interaction.vue","src/component/select-interaction/index.js"],"sourcesContent":["//\n//\n//\n//\n//\n//\n\nimport debounce from 'debounce-promise'\nimport { never, shiftKeyOnly, singleClick } from 'ol/events/condition'\nimport Feature from 'ol/Feature'\nimport SelectInteraction from 'ol/interaction/Select'\nimport { merge as mergeObs } from 'rxjs/observable'\nimport { map as mapOp } from 'rxjs/operators'\nimport Vue from 'vue'\nimport { featuresContainer, interaction, projTransforms, stylesContainer } from '../../mixin'\nimport { createStyle, defaultEditStyle, getFeatureId, getLayerId, initializeFeature } from '../../ol-ext'\nimport { observableFromOlEvent } from '../../rx-ext'\nimport { hasInteraction, hasMap } from '../../util/assert'\nimport { constant, difference, forEach, isEqual, isFunction, mapValues, stubArray } from '../../util/minilo'\nimport mergeDescriptors from '../../util/multi-merge-descriptors'\nimport { makeWatchers } from '../../util/vue-helpers'\n\nexport default {\n  name: 'vl-interaction-select',\n  mixins: [interaction, featuresContainer, stylesContainer, projTransforms],\n  stubVNode: {\n    empty: false,\n    attrs () {\n      return {\n        id: this.vmId,\n        class: this.cmpName,\n      }\n    },\n  },\n  props: {\n    /**\n     * A function that takes an `ol.Feature` and an `ol.layer.Layer` and returns `true` if the feature may be selected or `false` otherwise.\n     * @type {function|undefined}\n     */\n    filter: {\n      type: Function,\n      default: constant(true),\n    },\n    /**\n     * A list of layers from which features should be selected. Alternatively, a filter function can be provided.\n     * @type {string[]|function|undefined}\n     */\n    layers: {\n      type: [Array, Function],\n      default: undefined,\n    },\n    /**\n     * Hit-detection tolerance. Pixels inside the radius around the given position will be checked for features.\n     * This only works for the canvas renderer and not for WebGL.\n     * @type {number}\n     */\n    hitTolerance: {\n      type: Number,\n      default: 0,\n    },\n    /**\n     * A boolean that determines if the default behaviour should select only single features or all (overlapping)\n     * features at the clicked map position.\n     * @type {boolean}\n     */\n    multi: {\n      type: Boolean,\n      default: false,\n    },\n    /**\n     * Selected features as array of GeoJSON features with coordinates in the map view projection.\n     * @type {string[]|number[]|Object[]}\n     */\n    features: {\n      type: Array,\n      default: stubArray,\n    },\n    /**\n     * Wrap the world horizontally on the selection overlay.\n     * @type {boolean}\n     */\n    wrapX: {\n      type: Boolean,\n      default: true,\n    },\n    /**\n     * A function that takes an `ol.MapBrowserEvent` and returns a boolean to indicate whether that event should\n     * be handled. By default, this is `ol.events.condition.never`. Use this if you want to use different events\n     * for `add` and `remove` instead of `toggle`.\n     * @type {function|undefined}\n     */\n    addCondition: {\n      type: Function,\n      default: never,\n    },\n    /**\n     * A function that takes an `ol.MapBrowserEvent` and returns a boolean to indicate whether that event should be handled.\n     * This is the event for the selected features as a whole. By default, this is `ol.events.condition.singleClick`.\n     * Clicking on a feature selects that feature and removes any that were in the selection. Clicking outside any feature\n     * removes all from the selection.\n     * @type {function|undefined}\n     */\n    condition: {\n      type: Function,\n      default: singleClick,\n    },\n    /**\n     * A function that takes an `ol.MapBrowserEvent` and returns a boolean to indicate whether that event should be handled.\n     * By default, this is `ol.events.condition.never`. Use this if you want to use different events for `add` and `remove`\n     * instead of `toggle`.\n     * @type {function|undefined}\n     */\n    removeCondition: {\n      type: Function,\n      default: never,\n    },\n    /**\n     * A function that takes an `ol.MapBrowserEvent` and returns a boolean to indicate whether that event should be handled.\n     * This is in addition to the `condition` event. By default, `ol.events.condition.shiftKeyOnly`, i.e. pressing `shift`\n     * as well as the `condition` event, adds that feature to the current selection if it is not currently selected,\n     * and removes it if it is.\n     * @type {function|undefined}\n     */\n    toggleCondition: {\n      type: Function,\n      default: shiftKeyOnly,\n    },\n  },\n  computed: {\n    layerFilter () {\n      return Array.isArray(this.layers)\n        ? layer => this.layers.includes(getLayerId(layer))\n        : this.layers\n    },\n  },\n  methods: {\n    /**\n     * @return {Select}\n     * @protected\n     */\n    createInteraction () {\n      return new SelectInteraction({\n        features: this.$featuresCollection,\n        multi: this.multi,\n        wrapX: this.wrapX,\n        filter: this.filter,\n        layers: this.layerFilter,\n        hitTolerance: this.hitTolerance,\n        style: this.createStyleFunc(),\n        addCondition: this.addCondition,\n        condition: this.condition,\n        removeCondition: this.removeCondition,\n        toggleCondition: this.toggleCondition,\n      })\n    },\n    /**\n     * @return {function(feature: Feature): Style}\n     * @protected\n     */\n    getDefaultStyles () {\n      const defaultStyles = mapValues(defaultEditStyle(), styles => styles.map(createStyle))\n\n      return function __selectDefaultStyleFunc (feature) {\n        if (feature.getGeometry()) {\n          return defaultStyles[feature.getGeometry().getType()]\n        }\n      }\n    },\n    /**\n     * @returns {Object}\n     * @protected\n     */\n    getServices () {\n      return mergeDescriptors(\n        this::interaction.methods.getServices(),\n        this::stylesContainer.methods.getServices(),\n      )\n    },\n    /**\n     * @return {Interaction|undefined}\n     * @protected\n     */\n    getStyleTarget () {\n      return this.$interaction\n    },\n    /**\n     * @return {void}\n     * @protected\n     */\n    mount () {\n      this::interaction.methods.mount()\n      this.features.forEach(this.select)\n    },\n    /**\n     * @return {void}\n     * @protected\n     */\n    unmount () {\n      this.unselectAll()\n      this::interaction.methods.unmount()\n    },\n    /**\n     * @param {Object|Vue|Feature|string|number} feature\n     * @return {void}\n     * @throws {Error}\n     */\n    select (feature) {\n      feature = this.resolveFeature(feature)\n      if (!feature) return\n\n      this.addFeature(feature)\n    },\n    /**\n     * @param {Object|Vue|Feature|string|number} feature\n     * @return {void}\n     */\n    unselect (feature) {\n      feature = this.resolveFeature(feature)\n      if (!feature) return\n\n      this.removeFeature(feature)\n    },\n    /**\n     * Removes all features from selection.\n     * @return {void}\n     */\n    unselectAll () {\n      this.clearFeatures()\n    },\n    /**\n     * @param {Array<{style: Style, condition: (function|boolean|undefined)}>|function(feature: Feature): Style|Vue|undefined} styles\n     * @return {void}\n     * @protected\n     */\n    setStyle (styles) {\n      if (styles !== this._styles) {\n        this._styles = styles\n        this.scheduleRefresh()\n      }\n    },\n    /**\n     * @return {void}\n     * @protected\n     */\n    subscribeAll () {\n      this::interaction.methods.subscribeAll()\n      this::subscribeToInteractionChanges()\n    },\n    /**\n     * @param {Object|Vue|Feature|string|number} feature\n     * @return {Feature}\n     */\n    resolveFeature (feature) {\n      hasMap(this)\n\n      if (feature instanceof Vue) {\n        feature = feature.$feature\n      }\n\n      if (feature instanceof Feature) {\n        return feature\n      }\n\n      const featureId = getFeatureId(feature)\n      if (!featureId) {\n        throw new Error('Undefined feature id')\n      }\n\n      feature = undefined\n      forEach(this.$map.getLayers().getArray(), layer => {\n        if (this.layerFilter && !this.layerFilter(layer)) {\n          return false\n        }\n\n        const source = layer.getSource()\n        if (source && isFunction(source.getFeatureById)) {\n          feature = source.getFeatureById(featureId)\n        }\n\n        return !feature\n      })\n\n      return feature\n    },\n  },\n  watch: {\n    features: {\n      deep: true,\n      handler (features) {\n        if (!this.$interaction || isEqual(features, this.featuresDataProj)) return\n        // select new features\n        features.forEach(feature => {\n          feature = initializeFeature({ ...feature })\n          this.select(feature)\n        })\n        // unselect non-matched features\n        difference(\n          this.getFeatures(),\n          features,\n          (a, b) => getFeatureId(a) === getFeatureId(b),\n        ).forEach(::this.unselect)\n      },\n    },\n    featuresDataProj: {\n      deep: true,\n      handler: debounce(function (features) {\n        this.$emit('update:features', features.slice())\n      }, 1000 / 60),\n    },\n    ...makeWatchers([\n      'filter',\n      'hitTolerance',\n      'multi',\n      'wrapX',\n      'addCondition',\n      'condition',\n      'removeCondition',\n      'toggleCondition',\n    ], () => function () {\n      this.scheduleRecreate()\n    }),\n  },\n}\n\n/**\n * @return {void}\n * @private\n */\nfunction subscribeToInteractionChanges () {\n  hasInteraction(this)\n\n  const select = observableFromOlEvent(this.$featuresCollection, 'add')\n    .pipe(\n      mapOp(({ element }) => ({ type: 'select', feature: element })),\n    )\n  const unselect = observableFromOlEvent(this.$featuresCollection, 'remove')\n    .pipe(\n      mapOp(({ element }) => ({ type: 'unselect', feature: element })),\n    )\n  const events = mergeObs(select, unselect)\n\n  this.subscribeTo(events, evt => {\n    ++this.rev\n\n    this.$nextTick(() => {\n      this.$emit(evt.type, evt.feature)\n    })\n  })\n}\n","<template>\n  <i :id=\"vmId\" :class=\"cmpName\" style=\"display: none !important;\">\n    <slot :features=\"featuresDataProj\" />\n  </i>\n</template>\n\n<script>\n  import debounce from 'debounce-promise'\n  import { never, shiftKeyOnly, singleClick } from 'ol/events/condition'\n  import Feature from 'ol/Feature'\n  import SelectInteraction from 'ol/interaction/Select'\n  import { merge as mergeObs } from 'rxjs/observable'\n  import { map as mapOp } from 'rxjs/operators'\n  import Vue from 'vue'\n  import { featuresContainer, interaction, projTransforms, stylesContainer } from '../../mixin'\n  import { createStyle, defaultEditStyle, getFeatureId, getLayerId, initializeFeature } from '../../ol-ext'\n  import { observableFromOlEvent } from '../../rx-ext'\n  import { hasInteraction, hasMap } from '../../util/assert'\n  import { constant, difference, forEach, isEqual, isFunction, mapValues, stubArray } from '../../util/minilo'\n  import mergeDescriptors from '../../util/multi-merge-descriptors'\n  import { makeWatchers } from '../../util/vue-helpers'\n\n  export default {\n    name: 'vl-interaction-select',\n    mixins: [interaction, featuresContainer, stylesContainer, projTransforms],\n    stubVNode: {\n      empty: false,\n      attrs () {\n        return {\n          id: this.vmId,\n          class: this.cmpName,\n        }\n      },\n    },\n    props: {\n      /**\n       * A function that takes an `ol.Feature` and an `ol.layer.Layer` and returns `true` if the feature may be selected or `false` otherwise.\n       * @type {function|undefined}\n       */\n      filter: {\n        type: Function,\n        default: constant(true),\n      },\n      /**\n       * A list of layers from which features should be selected. Alternatively, a filter function can be provided.\n       * @type {string[]|function|undefined}\n       */\n      layers: {\n        type: [Array, Function],\n        default: undefined,\n      },\n      /**\n       * Hit-detection tolerance. Pixels inside the radius around the given position will be checked for features.\n       * This only works for the canvas renderer and not for WebGL.\n       * @type {number}\n       */\n      hitTolerance: {\n        type: Number,\n        default: 0,\n      },\n      /**\n       * A boolean that determines if the default behaviour should select only single features or all (overlapping)\n       * features at the clicked map position.\n       * @type {boolean}\n       */\n      multi: {\n        type: Boolean,\n        default: false,\n      },\n      /**\n       * Selected features as array of GeoJSON features with coordinates in the map view projection.\n       * @type {string[]|number[]|Object[]}\n       */\n      features: {\n        type: Array,\n        default: stubArray,\n      },\n      /**\n       * Wrap the world horizontally on the selection overlay.\n       * @type {boolean}\n       */\n      wrapX: {\n        type: Boolean,\n        default: true,\n      },\n      /**\n       * A function that takes an `ol.MapBrowserEvent` and returns a boolean to indicate whether that event should\n       * be handled. By default, this is `ol.events.condition.never`. Use this if you want to use different events\n       * for `add` and `remove` instead of `toggle`.\n       * @type {function|undefined}\n       */\n      addCondition: {\n        type: Function,\n        default: never,\n      },\n      /**\n       * A function that takes an `ol.MapBrowserEvent` and returns a boolean to indicate whether that event should be handled.\n       * This is the event for the selected features as a whole. By default, this is `ol.events.condition.singleClick`.\n       * Clicking on a feature selects that feature and removes any that were in the selection. Clicking outside any feature\n       * removes all from the selection.\n       * @type {function|undefined}\n       */\n      condition: {\n        type: Function,\n        default: singleClick,\n      },\n      /**\n       * A function that takes an `ol.MapBrowserEvent` and returns a boolean to indicate whether that event should be handled.\n       * By default, this is `ol.events.condition.never`. Use this if you want to use different events for `add` and `remove`\n       * instead of `toggle`.\n       * @type {function|undefined}\n       */\n      removeCondition: {\n        type: Function,\n        default: never,\n      },\n      /**\n       * A function that takes an `ol.MapBrowserEvent` and returns a boolean to indicate whether that event should be handled.\n       * This is in addition to the `condition` event. By default, `ol.events.condition.shiftKeyOnly`, i.e. pressing `shift`\n       * as well as the `condition` event, adds that feature to the current selection if it is not currently selected,\n       * and removes it if it is.\n       * @type {function|undefined}\n       */\n      toggleCondition: {\n        type: Function,\n        default: shiftKeyOnly,\n      },\n    },\n    computed: {\n      layerFilter () {\n        return Array.isArray(this.layers)\n          ? layer => this.layers.includes(getLayerId(layer))\n          : this.layers\n      },\n    },\n    methods: {\n      /**\n       * @return {Select}\n       * @protected\n       */\n      createInteraction () {\n        return new SelectInteraction({\n          features: this.$featuresCollection,\n          multi: this.multi,\n          wrapX: this.wrapX,\n          filter: this.filter,\n          layers: this.layerFilter,\n          hitTolerance: this.hitTolerance,\n          style: this.createStyleFunc(),\n          addCondition: this.addCondition,\n          condition: this.condition,\n          removeCondition: this.removeCondition,\n          toggleCondition: this.toggleCondition,\n        })\n      },\n      /**\n       * @return {function(feature: Feature): Style}\n       * @protected\n       */\n      getDefaultStyles () {\n        const defaultStyles = mapValues(defaultEditStyle(), styles => styles.map(createStyle))\n\n        return function __selectDefaultStyleFunc (feature) {\n          if (feature.getGeometry()) {\n            return defaultStyles[feature.getGeometry().getType()]\n          }\n        }\n      },\n      /**\n       * @returns {Object}\n       * @protected\n       */\n      getServices () {\n        return mergeDescriptors(\n          this::interaction.methods.getServices(),\n          this::stylesContainer.methods.getServices(),\n        )\n      },\n      /**\n       * @return {Interaction|undefined}\n       * @protected\n       */\n      getStyleTarget () {\n        return this.$interaction\n      },\n      /**\n       * @return {void}\n       * @protected\n       */\n      mount () {\n        this::interaction.methods.mount()\n        this.features.forEach(this.select)\n      },\n      /**\n       * @return {void}\n       * @protected\n       */\n      unmount () {\n        this.unselectAll()\n        this::interaction.methods.unmount()\n      },\n      /**\n       * @param {Object|Vue|Feature|string|number} feature\n       * @return {void}\n       * @throws {Error}\n       */\n      select (feature) {\n        feature = this.resolveFeature(feature)\n        if (!feature) return\n\n        this.addFeature(feature)\n      },\n      /**\n       * @param {Object|Vue|Feature|string|number} feature\n       * @return {void}\n       */\n      unselect (feature) {\n        feature = this.resolveFeature(feature)\n        if (!feature) return\n\n        this.removeFeature(feature)\n      },\n      /**\n       * Removes all features from selection.\n       * @return {void}\n       */\n      unselectAll () {\n        this.clearFeatures()\n      },\n      /**\n       * @param {Array<{style: Style, condition: (function|boolean|undefined)}>|function(feature: Feature): Style|Vue|undefined} styles\n       * @return {void}\n       * @protected\n       */\n      setStyle (styles) {\n        if (styles !== this._styles) {\n          this._styles = styles\n          this.scheduleRefresh()\n        }\n      },\n      /**\n       * @return {void}\n       * @protected\n       */\n      subscribeAll () {\n        this::interaction.methods.subscribeAll()\n        this::subscribeToInteractionChanges()\n      },\n      /**\n       * @param {Object|Vue|Feature|string|number} feature\n       * @return {Feature}\n       */\n      resolveFeature (feature) {\n        hasMap(this)\n\n        if (feature instanceof Vue) {\n          feature = feature.$feature\n        }\n\n        if (feature instanceof Feature) {\n          return feature\n        }\n\n        const featureId = getFeatureId(feature)\n        if (!featureId) {\n          throw new Error('Undefined feature id')\n        }\n\n        feature = undefined\n        forEach(this.$map.getLayers().getArray(), layer => {\n          if (this.layerFilter && !this.layerFilter(layer)) {\n            return false\n          }\n\n          const source = layer.getSource()\n          if (source && isFunction(source.getFeatureById)) {\n            feature = source.getFeatureById(featureId)\n          }\n\n          return !feature\n        })\n\n        return feature\n      },\n    },\n    watch: {\n      features: {\n        deep: true,\n        handler (features) {\n          if (!this.$interaction || isEqual(features, this.featuresDataProj)) return\n          // select new features\n          features.forEach(feature => {\n            feature = initializeFeature({ ...feature })\n            this.select(feature)\n          })\n          // unselect non-matched features\n          difference(\n            this.getFeatures(),\n            features,\n            (a, b) => getFeatureId(a) === getFeatureId(b),\n          ).forEach(::this.unselect)\n        },\n      },\n      featuresDataProj: {\n        deep: true,\n        handler: debounce(function (features) {\n          this.$emit('update:features', features.slice())\n        }, 1000 / 60),\n      },\n      ...makeWatchers([\n        'filter',\n        'hitTolerance',\n        'multi',\n        'wrapX',\n        'addCondition',\n        'condition',\n        'removeCondition',\n        'toggleCondition',\n      ], () => function () {\n        this.scheduleRecreate()\n      }),\n    },\n  }\n\n  /**\n   * @return {void}\n   * @private\n   */\n  function subscribeToInteractionChanges () {\n    hasInteraction(this)\n\n    const select = observableFromOlEvent(this.$featuresCollection, 'add')\n      .pipe(\n        mapOp(({ element }) => ({ type: 'select', feature: element })),\n      )\n    const unselect = observableFromOlEvent(this.$featuresCollection, 'remove')\n      .pipe(\n        mapOp(({ element }) => ({ type: 'unselect', feature: element })),\n      )\n    const events = mergeObs(select, unselect)\n\n    this.subscribeTo(events, evt => {\n      ++this.rev\n\n      this.$nextTick(() => {\n        this.$emit(evt.type, evt.feature)\n      })\n    })\n  }\n</script>\n","import { pick } from '../../util/minilo'\nimport Interaction from './interaction.vue'\n\nfunction plugin (Vue, options = {}) {\n  if (plugin.installed) {\n    return\n  }\n  plugin.installed = true\n\n  options = pick(options, 'dataProjection')\n  Object.assign(Interaction, options)\n\n  Vue.component(Interaction.name, Interaction)\n}\n\nexport default plugin\n\nexport {\n  Interaction,\n  plugin as install,\n}\n"],"names":["name","mixins","interaction","featuresContainer","stylesContainer","projTransforms","stubVNode","empty","attrs","id","vmId","class","cmpName","props","filter","type","Function","default","constant","layers","Array","undefined","hitTolerance","Number","multi","Boolean","features","stubArray","wrapX","addCondition","never","condition","singleClick","removeCondition","toggleCondition","shiftKeyOnly","computed","layerFilter","layer","getLayerId","methods","createInteraction","SelectInteraction","$featuresCollection","style","createStyleFunc","getDefaultStyles","defaultStyles","mapValues","defaultEditStyle","styles","createStyle","__selectDefaultStyleFunc","feature","getGeometry","getType","getServices","mergeDescriptors","getStyleTarget","$interaction","mount","select","unmount","unselectAll","resolveFeature","addFeature","unselect","removeFeature","clearFeatures","setStyle","_styles","scheduleRefresh","subscribeAll","subscribeToInteractionChanges","hasMap","Vue","$feature","Feature","featureId","getFeatureId","Error","forEach","$map","getLayers","getArray","source","getSource","isFunction","getFeatureById","watch","deep","handler","isEqual","featuresDataProj","initializeFeature","difference","getFeatures","a","b","debounce","$emit","makeWatchers","scheduleRecreate","hasInteraction","observableFromOlEvent","pipe","mapOp","element","events","mergeObs","subscribeTo","evt","rev","$nextTick","plugin","options","installed","pick","Interaction","component"],"mappings":"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"}